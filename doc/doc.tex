\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6.5in, 10in}]{geometry}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{hyperref}

\newcommand{\icd}[1]{\texttt{#1}}
\newcommand{\ccd}[1]{\colorbox{gray!15!white}{\texttt{#1}}}
\newcommand{\scd}[1]{
	\vspace*{5pt}

	\ccd{#1}
	\vspace*{5pt}
}
\newcommand{\nscd}[1]{\scd{\$ #1}}
\newcommand{\sscd}[1]{\scd{\$ sudo #1}}
\newcommand{\aptinstall}[1]{\sscd{apt install #1}}
\newcommand{\snapinstall}[1]{\sscd{snap install #1}}
\newcommand{\defos}{Ubuntu 20.10}
\newcommand{\psubinst}{possible installation using \icd{snap} on \defos}
\newcommand{\pubinst}{possible installation using \icd{apt} on \defos}
\newcommand{\pname}{brandy0}

\begin{document}

\author{Viktor Fukala}
\title{\pname: Fluid Flow Simulator}
\maketitle

\section{User Documentation}
\subsection{\pname}
\pname{} is a computer program that computes and displays the temporal evolution of the state of a fluid inside a two-dimentional container. To start the computation, the user must specifiy the parameters and boundary conditions the fluid should have and satisfy. The program also permits changing the parameters the computational model such as the sizes of the temporal and spacial steps during the simulation. When at least some states of the fuild are computed, the program allows the user to visualize them as a continuous video.

\subsection{Installation}

\pname{} can be distributed as a single executable file which dynamically links to libraries it depends on. The executable file itself can (in some cases) be directly downloaded from the project repository or it can be compiled from source. Either way, dependencies in the list that follows must be installed whenever \pname{} runs.

\subsubsection{Dependencies required at run time}\label{sec:runtimedeps}
For every dependency listed below, automatically include all its dependencies. (If using a package manager, they typically install automatically.)
\begin{itemize}
	\item gtkmm 3 (a C++ interface for GTK (GTK+) -- a GUI library)
		\begin{itemize}
			\item \pubinst{} (similarly for another linux package manager)
				\aptinstall{libgtkmm-3.0-1v5}
			\item Other versions, such as gtkmm 2 or gtkmm 4, are not compatible.
		\end{itemize}
	\item some ffmpeg libraries
		\begin{itemize}
			\item specifically \icd{libavcodec}, \icd{libavformat}, \icd{libavutil}, \icd{libswscale}
			\item \pubinst
				\sscd{add-apt-repository universe}
				\aptinstall{libavcodec58 libavformat58 libavutil56 libswscale5}
		\end{itemize}
\end{itemize}

\subsubsection{Additional dependencies required for compilation}\label{sec:compiledeps}
\begin{itemize}
	\item developer packages for the above run-time dependencies (unless the developer files were already included in the main package)
		\begin{itemize}
			\item \pubinst
				\vspace*{5pt}

				\ccd{\$ sudo apt install libgtkmm-3.0-dev libavcodec-dev libavformat-dev \textbackslash}\\
				\ccd{libavutil-dev libswscale-dev}
				\vspace*{5pt}
		\end{itemize}
	\item a C++17-compliant C++ compiler
		\begin{itemize}
			\item for example: possible installation of the GCC compiler using \icd{apt} on \defos
				\aptinstall{g++}
		\end{itemize}
	\item CMake version 3.16 or higher (a build automation tool)
		\begin{itemize}
			\item \psubinst{} (recommended)
				\snapinstall{cmake}
			\item \pubinst
				\aptinstall{cmake}
			\item Older versions of CMake may work fine too, but then it is necessary to edit the minimum required version in \icd{CMakeLists.txt}.
		\end{itemize}
	\item make (a build automation tool)
		\begin{itemize}
			\item \pubinst
				\aptinstall{make}
		\end{itemize}
	\item pkg-config (a build tool for fetching appropriate compiler flags)
		\begin{itemize}
			\item \pubinst
				\aptinstall{pkg-config}
		\end{itemize}
\end{itemize}

\subsubsection{Installation steps}
\underline{If you already have the executable file for \pname{}}:
\begin{enumerate}
	\item
		Install all dependencies mentioned in \ref{sec:runtimedeps}.
	\item
		Run the executable.
\end{enumerate}
\underline{If you need to compile the source}:
\begin{enumerate}
	\item
		Install all dependencies mentioned in \ref{sec:runtimedeps} and \ref{sec:compiledeps}.
	\item
		Clone the repository. In what follows, it is assumed that \icd{\$REPO} is the root directory of the repository.
	\item
		Decide whether you want a \emph{debug} or a \emph{release} build (or both, one executable for each). A release build should produce a more optimized executable, but it will probably make the compilation take longer and limit potential debugging options.
	\item
		Create a directory for the build. In what follows, \icd{\$REPO/build/release} will be the build directory.
		\nscd{mkdir -p \$REPO/build/release}
	\item
		Let CMake generate its build environment.
		\nscd{cd \$REPO/build/release}
		\nscd{cmake -DCMAKE\_BUILD\_TYPE=Release \$REPO/src} (replace \icd{Release} with \icd{Debug} if you want a debug build)
	\item
		Let CMake build the project.
		\nscd{cmake --build .} (run this still inside \icd{\$REPO/build/release})
	\item
		Run the executable. It has been generated at \icd{\$REPO/build/release/app/brandy0}.
\end{enumerate}

\newcommand{\inull}{start interface}
\newcommand{\Inull}{Start Interface}
\newcommand{\ione}{configuration interface}
\newcommand{\Ione}{Configuration Interface}
\newcommand{\itwo}{simulation interface}
\newcommand{\Itwo}{Simulation Interface}

\subsection{Program Workflow}
The intended typical execution of the program can be logically divided into three phases.
\begin{enumerate}
	\item The \hyperref[sec:i0]{\inull}, which allows the user to initiate the configuration of a new simulation.
	\item The \hyperref[sec:i1]{\ione}, which allows the user to configure parameters of a simulation.
	\item The \hyperref[sec:i2]{\itwo}, which allows the user to play frames from the simulation that have already been computed, and which is being shown while the computation is running.
\end{enumerate}
The user may enter these interfaces in the above order, but they can also go back to the previous interface (unless they already are in the start interface)

\subsubsection{\Inull}\label{sec:i0}
The \inull{} consists of one main window with two buttons. The first button leaves the \inull{} and enters the \ione. The second button pops a second window with information about the program, but the main window remains open. Closing the popped up window with about information has no other effects. Closing the main window terminates the program.

% screenshot of i0 here (with the about box open)

\subsubsection{\Ione}\label{sec:i1}

The \ione{} consists of two windows by default. The main window allows the user to set various numerical parameters of the future simulation. (see >link here< for more detailed explanation of each parameter)

\subsubsection{\Itwo}\label{sec:i2}

\section{Technical Documentation}

\end{document}
